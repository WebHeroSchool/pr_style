# Практики для JavaScript

## 1. Имена для переменных и функций

Выберите простые для понимания короткие имена для переменных и функций.
Нужно стараться осмысленно называть переменные и функции, чтобы улучшить читабельность кода и самому не запутаться.


```js
//Плохо
let x1
let fe2
var xbqne

incrementerForMainLoopWhichSpansFromTenToTwenty
}
createNewMemberIfAgeOverTwentyOneAndMoonIsFull
```
```js
//Хорошо
let name
let age
var number

isLegalAge()
```

## 2. Избегайте глобальных переменных

Сведите к минимуму использование глобальных переменных. Это включает в себя все типы данных, объекты и функции. Глобальные переменные и функции могут быть перезаписаны другими сценариями. Используйте локальные переменные



```js
//Плохо
var current = null;
var labels = {
   'home':'home',
   'articles':'articles',
   'contact':'contact'
};
function init(){
};
function show(){
   current = 1;
};
function hide(){
   show();
};
```
```js
//Хорошо
module = function(){
   var current = null;
   var labels = {
      'home':'home',
      'articles':'articles',
      'contact':'contact'
   };
   var init = function(){
   };
   var show = function(){
      current = 1;
   };
   var hide = function(){
      show();
   }
   return{init:init, show:show, current:current}
}();
module.init();
```
Сохраняйте согласованный синтаксис и смешивайте и сопоставляйте то, что нужно сделать глобальным.

## 3. Не используйте document.write

Старый верный метод document.write не рекомендуется использовать уже несколько лет. Однако он встречается еще очень часто в коде.

```js
document.write("hello world");
```
Вместо использования нерекомендованного метода нужно применять функцию innerHTML в совокупности со структурой DOM, чтобы вставить текст на страницу:
```js
document.getElementById('hello').innerHTML('hello world');
```
## 4. Комментируйте столько, сколько нужно, но не более

Прокомментируйте то, что считаете нужным, но не рассказывайте другим свою историю жизни.

Избегайте использования комментария строки //. / * * / гораздо безопаснее использовать, потому что он не вызывает ошибок при удалении разрыва строки.


## 5. Используйте сокращённые обозначения
Cокращённые обозначения позволяют вам писать быстрее код и повышают читабельность.


```js
//Код
var lunch = new Array();
lunch[0]='Dosa';
lunch[1]='Roti';
lunch[2]='Rice';
lunch[3]='what the heck is this?';

//Все равно что:
var lunch = [
   'Dosa',
   'Roti',
   'Rice',
   'what the heck is this?'
];
```
```js
//Код
if(v){
   var x = v;
} else {
   var x =10;
}

//Все равно что:
var x = v || 10;
```

## 6. Оптимизировать циклы
>Циклы могут быть ужасно медленными в JavaScript

Не заставляйте JavaScript читать длину массива на каждой итерации цикла for. Сохраните значение длины в другой переменной.
Cвойство length у массива считается динамически (т.е. при каждом обращении к нему), что может сказаться на производительности цикла при больших размерах массива. Поэтому всегда кешируйте значение свойства length
```js
//Плохо
var names = ['George',
'Ringo',
'Paul',
'John'];
for(var i=0;i<names.length;i++){
   doSomethingWith(names[i]);
}
```
```js
//Хорошо
var names = ['George',
'Ringo',
'Paul',
'John'];
for(var i=0,j=names.length;i<j;i++){
   doSomethingWith(names[i]);
}
```

## 7. Никогда не объявляйте Number, String или Boolean как объекты
Всегда рассматривайте числа, строки или Булев как примитивные значения. Не в качестве объектов.

Объявив эти типы в качестве объектов, замедляется скорость выполнения, и случаются неприятные побочные эффекты:

```js
var x = "John";
var y = new String("John");
(x === y) // is false because x is a string and y is an object.
```

Или еще хуже:
```js
var x = new String("John");
var y = new String("John");
(x == y) // is false because you cannot compare objects.
```

## 8. Сравнивайте значения переменных с помощью операторов === и !==
JavaScript — язык без строгой типизации. Это значит, что значение переменной может менять свой тип в зависимости от контекста, в котором это значение используется. Естественно, в JavaScript есть вполне четкие правила преобразования одного типа данных в другой, но иногда они ведут себя немного неочевидно. Например:
```js
console.log(0 == "0"); //true
console.log(!!0); // false
console.log(!!"0"); // true
```
Иными словами, несмотря на то, что строка "0" равна числу 0, а число 0 — значение ложное, строка "0" — значение истинное. Чтобы избежать подобных проблем, либо изучите абсолютно все правила преобразования типов, либо используйте операторы === и !== для сравнения. Эти операторы аналогичны == и != соответственно, но не приводят типы перед сравнением:
```js
console.log(0 === "0"); // false
```
## 9. Не используйте ключевое слово this без понимания концепции контекста исполнения
В JavaScript ключевое слово this работает не совсем так, как в большинстве других языков. В частности, во время вызова функции разработчик может переопределить значение, на которое указывает this. Это называется контекстом исполнения. По умолчанию this указывает на глобальный объект, а внутри методов объекта — на объект-владелец метода:
```js
var getThis = function () {
    if (this === window) console.log("Global context");
    else console.log("Context:", this);
};
var myObj = {
    name: "My test object",
    getThis: getThis
};
getThis();
myObj.getThis();
```
Ошибки начинаются, когда метод объекта создает callback-функцию или замыкание, потому что внутри них this опять указывает на глобальный объект, контекст исполнения новой функции не наследуется из оборачивающей функции в отличие от области видимости. Решений этой проблемы существует два. Простейшее решение — записать значение this в какую-нибудь переменную и внутри вложенной функции использовать ее:
```js
var myObj = {
    doSomething: function () {
        var self = this;
        (function () {
            console.log(self, this);
        })();
    }
};
myObj.doSomething();
```
Другой вариант — использовать методы call() и apply(), которые есть у любой функции. Эти методы позволяют задать контекст исполнения в момент вызова функции:
```js
var myObj = {
    doSomething: function () {
        return function () {
            console.log(this);
        }.bind(this);
    }
};
var fn = myObj.doSomething();
fn();
```
Недостатком метода bind() является невозможность дальнейшего изменения контекста исполнения функции, поэтому злоупотреблять им не стоит.
## 10. Стрелочные функции
Одной из самых заметных новшеств современного JavaScript стало появление стрелочных функций (arrow function), которые иногда называют «толстыми» стрелочными функциями (fat arrow function). При объявлении таких функций используют особую комбинацию символов — =>.
У стрелочных функций есть два основных преимущества перед традиционными функциями. Первое — это очень удобный и компактный синтаксис. Второе заключается в том, что подход к работе со значением this в стрелочных функциях выглядит интуитивно понятнее, чем в обычных функциях.

`func = () => console.log('Hello');`

Всё равно что:

```js
const func = function() {
    return console.log('Hello');
}
```
Главная причина появления стрелочных функций в ES6 — недопонимание, которое возникает у большинства разработчиков при работе с ключевым словом this. Чтобы понять, что же такого чудесного принесли с собой стрелочные функции рассмотрим простой пример:
```js
// ES5
var obj = {
  btn: document.links[0],
  log: function (message) {
    console.log(message);
    return this;
  },
  init: function() {
    var self = this;
    self.btn.addEventListener('click', function() {
      self.log('Button Clicked!');
    }, false);
  }
};
```
Чтобы выполнить какой-либо метод из объекта до появления стрелочных функций, необходимо было воспользоваться одним из методов замены ключевого слова this: как в этом примере записать его в переменную self, или воспользоваться методом функций bind. Данные способы, несмоненно, работали, но выглядели достаточно скверно и могли смутить других разработчиков, которые попытались бы разобраться в коде. Стрелочные функции полностью решают данную проблему. Теперь код, приведённый выше, будет выглядеть следующим образом:
```js
// ES6
var obj = {
  btn: document.links[0],
  log: function(message) {
    console.log(message);
    return this;
  },
  init: function() {
    this.btn.addEventListener('click', () => this.log('Button Clicked!'), false);
  }
};
```
#### Когда не стоит использовать стрелочные функции

Узнав немного больше о стрелочных функциях, я надеюсь, вы понимаете, что они не заменяют обычные функции.

Вот несколько примеров, когда вы, вероятно, не захотите их использовать:

1. Методы объекта
Когда вы вызываете cat.jumps, количество жизней не уменьшается. Это связано с тем, что this не связано ни с чем, и наследует значение this из его родительской области.
```js
var cat = {
  lives: 9,
  jumps: () => {
    this.lives--;
  }
}
```
2. Функции обратного вызова с динамическим контекстом
Если вам нужно, чтобы ваш контекст был динамическим, стрелочная функция не является правильным выбором. Взгляните на этот обработчик событий ниже:
```js
var button = document.getElementById('press');
button.addEventListener('click', () => {
  this.classList.toggle('on');
})
```
Если мы нажмем кнопку, мы получим TypeError. Это связано с тем, что она не привязана к кнопке, а привязана к ее родительской области.
